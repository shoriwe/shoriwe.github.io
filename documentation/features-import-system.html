<!doctype html><html lang=en><link href=/static/css/page.css rel=stylesheet><link href=/static/vendor/css/github-markdown.css rel=stylesheet><link href=/static/vendor/prism/prism.css rel=stylesheet><meta charset=utf-8><title>Documentation</title><div class=navigation-bar><a class="base-button plasma-title">Plasma</a>
<a class="base-button blue-button" href=/index.html>Home</a>
<a class="base-button green-button" href=/playground.html>Playground</a>
<a class="base-button purple-button" href=/documentation/docs.html>Documentation</a></div><div class=body-div><link href=/static/css/documentation.css rel=stylesheet><div class=documentation-container><div class=table-of-contents><article class=markdown-body><article class=markdown-body><h1><a href=/documentation/docs.html>Start</a></h1><h1><a href=/documentation/language.html>Language</a></h1><h2><a href=/documentation/built-in.html>Built-In</a></h2><h6><a href=/documentation/built-in-types.html>Types</a></h6><h6><a href=/documentation/built-in-functions.html>Functions</a></h6><h2><a href=/documentation/operators.html>Operators</a></h2><h2><a href=/documentation/indexing.html>Indexing</a></h2><h2><a href=/documentation/name-selectors.html>Name selectors</a></h2><h2><a href=/documentation/generators.html>Generators</a></h2><h2><a href=/documentation/function-definitions.html>Function definitions</a></h2><h6><a href=/documentation/function-definitions-named-functions.html>Named functions</a></h6><h6><a href=/documentation/function-definitions-lambda-functions.html>Lambda functions</a></h6><h2><a href=/documentation/assign.html>Assign</a></h2><h2><a href=/documentation/module.html>Module</a></h2><h2><a href=/documentation/class-interface.html>Class and Interface definitions</a></h2><h6><a href=/documentation/class-interface-classes.html>Classes</a></h6><h6><a href=/documentation/class-interface-interfaces.html>Interfaces</a></h6><h6><a href=/documentation/class-interface-super.html>Super</a></h6><h6><a href=/documentation/class-interface-magic-methods.html>Magic methods</a></h6><h2><a href=/documentation/if-unless.html>If/Unless statements</a></h2><h6><a href=/documentation/if-unless-if.html>If</a></h6><h6><a href=/documentation/if-unless-unless.html>Unless</a></h6><h2><a href=/documentation/switch.html>Switch</a></h2><h2><a href=/documentation/loops.html>Loops</a></h2><h6><a href=/documentation/loops-do-while.html>Do-While</a></h6><h6><a href=/documentation/loops-while.html>While</a></h6><h6><a href=/documentation/loops-until.html>Until</a></h6><h6><a href=/documentation/loops-for.html>For</a></h6><h6><a href=/documentation/loops-special-keyboards.html>Special Keyboards</a> &ndash; <a href=/documentation/loops-special-keyboards-break.html>Break</a> &ndash; <a href=/documentation/loops-special-keyboards-continue.html>Continue</a> &ndash; <a href=/documentation/loops-special-keyboards-redo.html>Redo</a></h6><h2><a href=/documentation/begin.html>Begin</a></h2><h2><a href=/documentation/end.html>End</a></h2><h2><a href=/documentation/pass.html>Pass</a></h2><h1><a href=/documentation/features.html>Features</a></h1><h6><a href=/documentation/features-import-system.html>Import system</a></h6><h6><a href=/documentation/features-object-loader.html>ObjectLoaders</a></h6><h1><a href=/documentation/embedding.html>Embedding</a></h1><h1><a href=/documentation/stdlib.html>Standard library</a></h1><h6><a href=/documentation/stdlib-regexp.html>regexp</a></h6><h6><a href=/documentation/stdlib-json.html>json</a></h6><h6><a href=/documentation/stdlib-base64.html>base64</a></h6></article></article></div><div class=documentation><article class=markdown-body><article class=markdown-body><h1>Import system</h1><p>Plasma has a built-in <strong><code>Feature</code></strong> to import external code from other scripts or for dynamically use external features.<h2>In Plasma usage</h2><pre><code class="language-ruby line-numbers"># Use `require(MODULE_NAME)` when you want to import plasma or built-in modules
my_module = require(&quot;my_module&quot;)

# Use `import(SCRIPT_NAME)` when you want to import a script
my_script = import(&quot;my-script.pm&quot;)

# Use `open_resource(RELATIVE_FILE_PATH)` when you want to have a file handler for a relative file of a module
index_html_template = open_resource(&quot;my_module/templates/index.template&quot;)

# Use `get_resource_path(RELATIVE_FILE_PATH)` when you want the full file path of a resource in a module
index_html_template_path = get_resource_path(&quot;my_module/templates/index.template&quot;)  
</code></pre><h2>Loading the feature</h2><pre><code class=language-go>package main

import (
	&quot;github.com/shoriwe/gplasma/pkg/std/features/importlib&quot;
	&quot;github.com/shoriwe/gplasma&quot;
	&quot;github.com/shoriwe/gplasma/pkg/std/modules/base64&quot;
	&quot;github.com/shoriwe/gplasma/pkg/std/modules/json&quot;
	&quot;github.com/shoriwe/gplasma/pkg/std/modules/regex&quot;
	&quot;os&quot;
)

func main() {
	virtualMachine := gplasma.NewVirtualMachine()
	currentDir, err := os.Getwd()
	if err != nil {
		currentDir = &quot;.&quot;
	}
	importSystem := importlib.NewImporter()
	// Load Default modules to use with the VM
	importSystem.LoadModule(regex.Regex)
	importSystem.LoadModule(json.JSON)
	importSystem.LoadModule(base64.Base64)
	//
	virtualMachine.LoadFeature(
		importSystem.Result( // Requesting the import system factory the final feature to load in the virtual machine
			importlib.NewRealFileSystem(sitePackagesPath),
			importlib.NewRealFileSystem(currentDir),
		),
	)
}
</code></pre><h2>Writing your own modules</h2><pre><code class=language-go>package main

import (
	&quot;github.com/shoriwe/gplasma/pkg/std/features/importlib&quot;
	&quot;github.com/shoriwe/gplasma&quot;
	&quot;github.com/shoriwe/gplasma/pkg/std/modules/base64&quot;
	&quot;github.com/shoriwe/gplasma/pkg/std/modules/json&quot;
	&quot;github.com/shoriwe/gplasma/pkg/std/modules/regex&quot;
	&quot;os&quot;
)

func myModuleLoader() gplasma.ObjectLoader {
	return func(context *gplasma.Context, p *gplasma.Plasma) *gplasma.Value {
		return p.NewInteger(context, false, 0)
	}
}

// Return a valid ModuleInformation to load in the import system
func myModule() importlib.ModuleInformation {
	return importlib.ModuleInformaiton{
		Name:   &quot;my_module&quot;,
		Loader: myModuleLoader(),
	}
}

func main() {
	virtualMachine := gplasma.NewVirtualMachine()
	currentDir, err := os.Getwd()
	if err != nil {
		currentDir = &quot;.&quot;
	}
	importSystem := importlib.NewImporter()
	// Load Default modules to use with the VM
	importSystem.LoadModule(myModule())
	//
	virtualMachine.LoadFeature(
		importSystem.Result( // Requesting the import system factory the final feature to load in the virtual machine
			importlib.NewRealFileSystem(sitePackagesPath),
			importlib.NewRealFileSystem(currentDir),
		),
	)
}
</code></pre><h2>Using a custom file system search engine</h2><p>In some scenarios you will need to import existing <code>Plasma</code> source code.<p>For this to succeed you will need to write a new type that implements <strong><code>importlib.FileSystem</code></strong>.<h3>Import order</h3><ul><li><p><code>import</code> will always ask only to the provided <code>pwd</code> <strong><code>importlib.FileSystem</code></strong>.<li><p>The loading order when calling <code>require</code> is:</ul><ol><li>It searches for a built-in module that has that name<li>If no built-in module was found, it asks the provided <code>sitePackages</code> <strong><code>importlib.FileSystem</code></strong> for a plasma module
with that name.</ol></article></article></div></div></div><script src=/static/vendor/prism/prism.js></script>